<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>SwiftUI 探索-状态和数据流 | He Xiao</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="SwiftUI 探索-状态和数据流" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="SwiftUI是iOS13新出的声明式UI框架，将会完全改变以前命令式操作UI的开发方式。此文章主要介绍SwiftUI中状态管理的方式。" />
<meta property="og:description" content="SwiftUI是iOS13新出的声明式UI框架，将会完全改变以前命令式操作UI的开发方式。此文章主要介绍SwiftUI中状态管理的方式。" />
<link rel="canonical" href="http://localhost:4000/ios/2019/06/13/SwiftUI-%E6%8E%A2%E7%B4%A2-%E7%8A%B6%E6%80%81%E5%92%8C%E6%95%B0%E6%8D%AE%E6%B5%81.html" />
<meta property="og:url" content="http://localhost:4000/ios/2019/06/13/SwiftUI-%E6%8E%A2%E7%B4%A2-%E7%8A%B6%E6%80%81%E5%92%8C%E6%95%B0%E6%8D%AE%E6%B5%81.html" />
<meta property="og:site_name" content="He Xiao" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-06-13T00:00:00+08:00" />
<script type="application/ld+json">
{"description":"SwiftUI是iOS13新出的声明式UI框架，将会完全改变以前命令式操作UI的开发方式。此文章主要介绍SwiftUI中状态管理的方式。","@type":"BlogPosting","url":"http://localhost:4000/ios/2019/06/13/SwiftUI-%E6%8E%A2%E7%B4%A2-%E7%8A%B6%E6%80%81%E5%92%8C%E6%95%B0%E6%8D%AE%E6%B5%81.html","headline":"SwiftUI 探索-状态和数据流","dateModified":"2019-06-13T00:00:00+08:00","datePublished":"2019-06-13T00:00:00+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/ios/2019/06/13/SwiftUI-%E6%8E%A2%E7%B4%A2-%E7%8A%B6%E6%80%81%E5%92%8C%E6%95%B0%E6%8D%AE%E6%B5%81.html"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="He Xiao" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">He Xiao</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a><a class="page-link" href="/category.html">Tag</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">SwiftUI 探索-状态和数据流</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2019-06-13T00:00:00+08:00" itemprop="datePublished">Jun 13, 2019
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p><code>SwiftUI</code>是<code>iOS13</code>新出的声明式UI框架，将会完全改变以前<code>命令式</code>操作UI的开发方式。此文章主要介绍<code>SwiftUI</code>中状态管理的方式。</p>
<h2 id="section">可变状态</h2>
<h4 id="state">@State</h4>
<p>与<code>React</code>和<code>Flutter</code>中的<code>State</code>类似，只不过<code>React</code>和<code>Flutter</code>中需要显式调用<code>setState</code>方法。在<code>SwiftUI</code> 中直接修改<code>State</code>属性值，就触发视图更新。</p>
<blockquote>
<p>因为<code>State</code>是使用了<code>@propertyDelegate</code>修饰的属性值，其内部实现应该是在状态值<code>set</code>方法中进行变更视图的操作。</p>
</blockquote>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">Model</span><span class="p">:</span> <span class="kt">BindableObject</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">didChange</span> <span class="o">=</span> <span class="kt">PassthroughSubject</span><span class="o">&lt;</span><span class="kt">Model</span><span class="p">,</span> <span class="kt">Never</span><span class="o">&gt;</span><span class="p">()</span>
    <span class="k">var</span> <span class="nv">count</span><span class="p">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="k">didSet</span> <span class="p">{</span>
            <span class="n">didChange</span><span class="o">.</span><span class="nf">send</span><span class="p">(</span><span class="k">self</span><span class="p">)</span><span class="c1">// 调用didChange触发变更操作</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">struct</span> <span class="kt">ContentView</span><span class="p">:</span> <span class="kt">View</span> <span class="p">{</span>
   <span class="kd">@State</span> <span class="kd">private</span> <span class="k">var</span> <span class="nv">text</span><span class="p">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">"a"</span><span class="c1">// 使用@State修饰</span>
   <span class="kd">@State</span> <span class="kd">private</span> <span class="k">var</span> <span class="nv">model</span> <span class="o">=</span> <span class="kt">Model</span><span class="p">()</span><span class="c1">// 使用@State修饰</span>
    <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="n">some</span> <span class="kt">View</span> <span class="p">{</span>
        <span class="kt">VStack</span> <span class="p">{</span>
          <span class="kt">Text</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
          <span class="kt">Text</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">count</span><span class="p">)</span>
          <span class="kt">Button</span><span class="p">(</span><span class="nv">action</span><span class="p">:</span> <span class="p">{</span>
              <span class="k">self</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="s">"b"</span><span class="c1">// 修改text会更新视图</span>
              <span class="k">self</span><span class="o">.</span><span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="p">})</span> <span class="p">{</span>
              <span class="kt">Text</span><span class="p">(</span><span class="s">"update-text"</span><span class="p">)</span>
          <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<ul>
<li>如果想使用<code>class</code>类型属性作为<code>State</code>属性，类对象需要实现<code>BindableObject</code>协议。当调用<code>didChange</code>的<code>send</code>方法时，会通知关联的<code>View</code>更新视图。<code>didChange</code>是<code>Publisher</code>（新出的<code>Combine</code>异步事件处理框架，类似<code>RxSwift</code>）类型，调用<code>send</code>时会发送一个新的值给订阅者。</li>
<li>当修改的<code>State</code>属性值没有在<code>body</code>中使用或者修改后的<code>State</code>属性值和上一次相同，并不会触发重新计算<code>body</code>。</li>
</ul>
<blockquote>
<p><code>State</code>属性修改时，会检测<code>State</code>属性被使用和检测值变更来决定要不要更新视图和触发<code>body</code>方法。</p>
</blockquote>
<ul>
<li><code>State</code>属性用<code>class</code>类型。在触发<code>body</code>重新计算前会检查<code>State</code>值有没有改变，当修改类对象属性时，因为类对象指针并没有改变，所以并不会触发视图更新。如果想触发视图变更，可以在修改<code>State</code>时生成新的对象（这种方式不太好）或者使用<code>BindableObject</code>。</li>
</ul>
<h2 id="section-1">属性</h2>
<h4 id="property">Property</h4>
<p>与<code>React</code>中的<code>Props</code>类似，用于父视图向子视图传递值。</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">PropertyView</span><span class="p">:</span> <span class="kt">View</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">text</span><span class="p">:</span> <span class="kt">String</span><span class="c1">// 当text改变时，会重新计算`body`。</span>
    <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="n">some</span> <span class="kt">View</span> <span class="p">{</span>
        <span class="kt">Text</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">struct</span> <span class="kt">ContentView</span><span class="p">:</span> <span class="kt">View</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="n">some</span> <span class="kt">View</span> <span class="p">{</span>
        <span class="kt">PropertyView</span><span class="p">(</span><span class="nv">text</span><span class="p">:</span> <span class="s">"a"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<ul>
<li>使用<code>let</code>变量。使用<code>var</code>变量修饰属性，在<code>body</code>方法里也不能修改，因为修改属性会创建新的结构体。</li>
</ul>
<h4 id="binding">@Binding</h4>
<p>与<code>Property</code>功能类似，用于父视图向子视图传递值。只不过<code>Binding</code>属性可以修改，修改<code>Binding</code>属性会触发父视图<code>State</code>改变重新计算<code>body</code>。可以实现反向数据流的功能，有点类似<code>MVVM</code>的双向绑定。</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">BindingView</span> <span class="p">:</span> <span class="kt">View</span> <span class="p">{</span>
    <span class="kd">@Binding</span> <span class="k">var</span> <span class="nv">text</span><span class="p">:</span> <span class="kt">String</span> <span class="c1">// 使用@Binding修饰</span>
    <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="n">some</span> <span class="kt">View</span> <span class="p">{</span>
        <span class="kt">VStack</span> <span class="p">{</span>
            <span class="kt">Button</span><span class="p">(</span><span class="nv">action</span><span class="p">:</span> <span class="p">{</span>
                <span class="k">self</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="s">"b"</span>
            <span class="p">})</span> <span class="p">{</span>
                <span class="kt">Text</span><span class="p">(</span><span class="s">"update-text"</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">struct</span> <span class="kt">ContentView</span> <span class="p">:</span> <span class="kt">View</span> <span class="p">{</span>
    <span class="kd">@State</span> <span class="kd">private</span> <span class="k">var</span> <span class="nv">text</span><span class="p">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="s">"a"</span> <span class="c1">// State</span>
    <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="n">some</span> <span class="kt">View</span> <span class="p">{</span>
        <span class="kt">VStack</span> <span class="p">{</span>
            <span class="kt">BindingView</span><span class="p">(</span><span class="nv">text</span><span class="p">:</span> <span class="err">$</span><span class="n">text</span><span class="p">)</span><span class="c1">// State变量使用$获取Binding</span>
            <span class="kt">Text</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="objectbinding">@ObjectBinding</h4>
<p><code>@ObjectBinding</code>似乎和<code>State</code>相似，暂时不太清楚使用上有什么区别。<code>@State</code>替换<code>@ObjectBinding</code>使用没有问题，<code>@Binding</code>替换<code>@ObjectBinding</code>使用也没有问题。</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">Model</span><span class="p">:</span> <span class="kt">BindableObject</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">didChange</span> <span class="o">=</span> <span class="kt">PassthroughSubject</span><span class="o">&lt;</span><span class="kt">Model</span><span class="p">,</span> <span class="kt">Never</span><span class="o">&gt;</span><span class="p">()</span>
    <span class="k">var</span> <span class="nv">count</span><span class="p">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="k">didSet</span> <span class="p">{</span>
            <span class="n">didChange</span><span class="o">.</span><span class="nf">send</span><span class="p">(</span><span class="k">self</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">struct</span> <span class="kt">ChildView</span><span class="p">:</span> <span class="kt">View</span> <span class="p">{</span>
<span class="c1">//    @Binding var model: Model</span>
<span class="c1">//    @ObjectBinding var model: Model</span>
    <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="n">some</span> <span class="kt">View</span> <span class="p">{</span>
        <span class="kt">VStack</span> <span class="p">{</span>
            <span class="kt">Text</span><span class="p">(</span><span class="s">"count2-</span><span class="se">\(</span><span class="n">model</span><span class="o">.</span><span class="n">count</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
            <span class="kt">Button</span><span class="p">(</span><span class="nv">action</span><span class="p">:</span> <span class="p">{</span>
                <span class="k">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="p">})</span> <span class="p">{</span>
                <span class="kt">Text</span><span class="p">(</span><span class="s">"update"</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">struct</span> <span class="kt">ContentView</span> <span class="p">:</span> <span class="kt">View</span> <span class="p">{</span>
<span class="c1">//    @State private var model = Model()</span>
<span class="c1">//    @ObjectBinding private var model = Model()</span>
    <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="n">some</span> <span class="kt">View</span> <span class="p">{</span>
        <span class="kt">VStack</span> <span class="p">{</span>
            <span class="kt">ChildView</span><span class="p">(</span><span class="nv">model</span><span class="p">:</span> <span class="n">model</span><span class="p">)</span>
            <span class="kt">Text</span><span class="p">(</span><span class="s">"count1-</span><span class="se">\(</span><span class="n">model</span><span class="o">.</span><span class="n">count</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<blockquote>
<p>上面<code>State</code>，<code>ObjectBinding</code>，<code>Binding</code>注释的地方任意使用结果都一样，视图能正确更新。</p>
</blockquote>
<h4 id="environmentobject">@EnvironmentObject</h4>
<p>通过<code>Property</code>或者<code>Binding</code>的方式，我们只能显式的通过组件树逐层传递。</p>
<blockquote>
<p>显式逐层传递的缺点</p>
<ul>
<li>当组件树复杂的时候特别繁琐，修改起来也很麻烦。</li>
<li>有些属性在视图树中间的层级不会使用到，只有底层会使用。会增加中间层级视图的复杂度。也可以避免中间的层级重复计算<code>body</code>触发视图更新。</li>
</ul>
</blockquote>
<p>为了避免层层传递属性，可以使用<code>Environment</code>变量。<code>Environment</code>属性可以在任意子视图获取并使用。和<code>React</code>中的<code>Context</code>很相似。</p>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">EnvironmentView1</span><span class="p">:</span> <span class="kt">View</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="n">some</span> <span class="kt">View</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kt">VStack</span> <span class="p">{</span>
            <span class="kt">EnvironmentView2</span><span class="p">()</span>
            <span class="kt">EnvironmentView3</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">struct</span> <span class="kt">EnvironmentView2</span><span class="p">:</span> <span class="kt">View</span> <span class="p">{</span>
    <span class="kd">@EnvironmentObject</span> <span class="k">var</span> <span class="nv">model</span><span class="p">:</span> <span class="kt">Model</span><span class="c1">// 使用@EnvironmentObject修饰属性</span>
    <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="n">some</span> <span class="kt">View</span> <span class="p">{</span>
       <span class="kt">Button</span><span class="p">(</span><span class="nv">action</span><span class="p">:</span> <span class="p">{</span>
                <span class="k">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="nf">change</span><span class="p">()</span>
            <span class="p">})</span> <span class="p">{</span>
                <span class="kt">Text</span><span class="p">(</span><span class="s">"update-Environment"</span><span class="p">)</span>
            <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">struct</span> <span class="kt">EnvironmentView3</span><span class="p">:</span> <span class="kt">View</span> <span class="p">{</span>
    <span class="kd">@EnvironmentObject</span> <span class="k">var</span> <span class="nv">model</span><span class="p">:</span> <span class="kt">Model</span><span class="c1">// EnvironmentObject</span>
    <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="n">some</span> <span class="kt">View</span> <span class="p">{</span>
        <span class="kt">Text</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">struct</span> <span class="kt">ContentView</span><span class="p">:</span> <span class="kt">View</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="n">some</span> <span class="kt">View</span> <span class="p">{</span>
        <span class="c1">//EnvironmentObject需要使用environmentObject方法注入到组件树中</span>
        <span class="kt">EnvironmentView1</span><span class="p">()</span><span class="o">.</span><span class="nf">environmentObject</span><span class="p">(</span><span class="kt">Model</span><span class="p">())</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<ul>
<li>通过<code>environmentObject</code>方法注入对象到组件树中，子组件树中共享同一个对象并且可以监听变更。</li>
<li><code>@EnvironmentObject</code>查找如何能获取到对应的对象，大概是根据属性的类型进行查找，所以多个属性只要类型相同，就能取到同样的对象。当组件树有多个组件使用<code>environmentObject</code>方法注入同类型的对象时，获取时会查找最近的父组件的对象。</li>
</ul>
<blockquote>
<p>目前好像没有方式实现根据不同的<code>key</code>来注入多个对象并获取。</p>
</blockquote>
<h2 id="section-2">数据流</h2>
<h4 id="gt-">父视图 -&gt; 子视图向下传递</h4>
<ul>
<li>不需要修改使用<code>Property</code></li>
<li>需要修改使用<code>@Binding</code></li>
</ul>
<h4 id="gt--1">父视图 -&gt; 子视图跨层级向下传递</h4>
<ul>
<li>EnvironmentObject</li>
</ul>
<h4 id="section-3">全局状态层管理</h4>
<ul>
<li>使用<code>environmentObject</code>方法注入多个全局状态类到程序的<code>根视图</code>，不太复杂的程序可以这样实现。</li>
<li>结合<code>Combine</code>框架根据功能模块进行领域模型拆分，使用的时候通过订阅通知的方式来通信。</li>
</ul>
<h3 id="section-4">视图更新流程</h3>
<ul>
<li>修改<code>State</code>触发视图更新，检测<code>State</code>是否被使用以及值是否被改变。</li>
<li>重新计算<code>body</code>生成新的视图树，会重新创建所有子视图的<code>View</code>结构体。</li>
<li>遍历所有子视图，判断<code>View</code>结构体与更新前是否一致。当不一致时，触发子视图更新，调用子视图<code>body</code>。</li>
</ul>
<h2 id="tips">Tips</h2>
<h4 id="state-1">关于 State</h4>
<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="kt">Model</span><span class="p">:</span> <span class="kt">BindableObject</span> <span class="p">{</span>
    <span class="k">var</span> <span class="nv">didChange</span> <span class="o">=</span> <span class="kt">PassthroughSubject</span><span class="o">&lt;</span><span class="kt">Model</span><span class="p">,</span> <span class="kt">Never</span><span class="o">&gt;</span><span class="p">()</span>
    <span class="k">var</span> <span class="nv">count</span><span class="p">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="k">didSet</span> <span class="p">{</span>
            <span class="n">didChange</span><span class="o">.</span><span class="nf">send</span><span class="p">(</span><span class="k">self</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"Model-init-</span><span class="se">\(</span><span class="n">count</span><span class="se">)</span><span class="s">"</span><span class="p">)</span><span class="c1">// 这里count始终为0</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">struct</span> <span class="kt">Struct</span> <span class="p">{</span>
    <span class="kd">private(set)</span> <span class="k">var</span> <span class="nv">count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"Struct-</span><span class="se">\(</span><span class="n">count</span><span class="se">)</span><span class="s">"</span><span class="p">)</span><span class="c1">// 这里count始终为0</span>
    <span class="p">}</span>
    <span class="k">mutating</span> <span class="kd">func</span> <span class="nf">update</span><span class="p">()</span> <span class="p">{</span>
        <span class="nf">print</span><span class="p">(</span><span class="s">"update-</span><span class="se">\(</span><span class="n">count</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
        <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kd">struct</span> <span class="kt">ChildView</span><span class="p">:</span> <span class="kt">View</span> <span class="p">{</span>
    <span class="kd">@State</span> <span class="kd">private</span> <span class="k">var</span> <span class="nv">model2</span> <span class="o">=</span> <span class="kt">Struct</span><span class="p">()</span>
    <span class="kd">@State</span> <span class="kd">private</span> <span class="k">var</span> <span class="nv">model</span> <span class="o">=</span> <span class="kt">Model2</span><span class="p">()</span>
    <span class="kd">@State</span> <span class="kd">private</span> <span class="k">var</span> <span class="nv">count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="n">some</span> <span class="kt">View</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kt">VStack</span> <span class="p">{</span>
            <span class="kt">Text</span><span class="p">(</span><span class="s">"</span><span class="se">\(</span><span class="n">model</span><span class="o">.</span><span class="n">count</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
            <span class="kt">Text</span><span class="p">(</span><span class="s">"</span><span class="se">\(</span><span class="n">model2</span><span class="o">.</span><span class="n">count</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
            <span class="kt">Text</span><span class="p">(</span><span class="s">"</span><span class="se">\(</span><span class="n">count</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
            <span class="kt">Button</span><span class="p">(</span><span class="nv">action</span><span class="p">:</span> <span class="p">{</span><span class="c1">// 修改 State</span>
                <span class="k">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">self</span><span class="o">.</span><span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">self</span><span class="o">.</span><span class="n">model2</span><span class="o">.</span><span class="nf">update</span><span class="p">()</span>
            <span class="p">})</span> <span class="p">{</span>
                <span class="kt">Text</span><span class="p">(</span><span class="s">"update"</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
<span class="p">}</span>
<span class="kd">struct</span> <span class="kt">ContentView</span><span class="p">:</span> <span class="kt">View</span> <span class="p">{</span>
    <span class="kd">@State</span> <span class="kd">private</span> <span class="k">var</span> <span class="nv">count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">var</span> <span class="nv">body</span><span class="p">:</span> <span class="n">some</span> <span class="kt">View</span> <span class="p">{</span>
        <span class="k">return</span> <span class="kt">VStack</span> <span class="p">{</span>
            <span class="kt">ChildView</span><span class="p">()</span>
            <span class="kt">Button</span><span class="p">(</span><span class="nv">action</span><span class="p">:</span> <span class="p">{</span>
                <span class="k">self</span><span class="o">.</span><span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="p">})</span> <span class="p">{</span>
                <span class="kt">Text</span><span class="p">(</span><span class="s">"update"</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="kt">Text</span><span class="p">(</span><span class="s">"</span><span class="se">\(</span><span class="n">count</span><span class="se">)</span><span class="s">"</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<ul>
<li>当<code>ContentView</code>更新时，会重新创建<code>ChildView</code>结构体。</li>
<li><code>ChildView</code>中的<code>State</code>都会重新创建，<code>Struct</code>和<code>Model</code>初始化方法中，<code>count</code>一直为<code>0</code>，即使<code>ContentView</code>里<code>State</code>曾经修改过。但是下一次修改<code>State</code>值时，<code>State</code>会使用之前的值做运算。</li>
</ul>
<blockquote>
<p>不太清楚这里是如何处理的，<code>State</code>虽然重新初始化了一次，似乎还是使用的之前的<code>State</code>。</p>
<ol>
<li>例如当点击Button时，会修改<code>ChildView</code>中<code>model</code>, <code>model2</code>中<code>count</code>+=1，当前<code>count</code>=1。</li>
<li>当<code>ChildView</code>重新创建时，<code>model</code>，<code>model2</code>初始化方法中，<code>count</code>=0。</li>
<li>当下一次点击Button修改<code>count</code>值时，<code>count</code>会在1的基础上+1，之后<code>count</code>=2。</li>
</ol>
</blockquote>
<h4 id="section-5">性能</h4>
<ul>
<li>当视图发生变更时，由于<code>body</code>会经常重新计算，所以应该尽量避免在<code>body</code>中进行重复和耗时计算。</li>
<li>视图变更时，视图组件<code>View</code>结构体会重新创建，所以应该避免在<code>init</code>方法中进行重复和耗时计算。（包括属性的重新生成）</li>
<li>根据上面 <code>State</code>的特性，当<code>State</code>属性为结构体或类时，应避免在<code>init</code>方法中访问或修改属性。因为当State修改过后，在<code>init</code>方法中获取到的值不是正确的，修改值也会生效。</li>
</ul>

  </div><a class="u-url" href="/ios/2019/06/13/SwiftUI-%E6%8E%A2%E7%B4%A2-%E7%8A%B6%E6%80%81%E5%92%8C%E6%95%B0%E6%8D%AE%E6%B5%81.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">He Xiao</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">He Xiao</li><li><a class="u-email" href="mailto:hexiao.x@foxmail.com">hexiao.x@foxmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/helele90"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">helele90</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Blog.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
